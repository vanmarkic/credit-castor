rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Users collection - store custom authentication data
    match /users/{userId} {
      // Anyone can create a new user (for registration)
      allow create: if true;

      // Users can only read their own data
      allow read: if request.auth != null || request.resource.data.email == userId.replace('_', '@').replace('_', '.');

      // Users cannot update/delete (security measure)
      allow update, delete: if false;
    }

    // Projects collection - shared project data
    match /projects/{projectId} {
      // Allow read if unlocked (we check unlock state in the app)
      allow read: if true;

      // Helper function to validate TravauxCommuns structure
      function isValidTravauxCommuns(travauxCommuns) {
        // enabled must be boolean if present
        let enabledValid = !exists(travauxCommuns.enabled) || travauxCommuns.enabled is bool;
        
        // If items exist, they must be a list
        // Note: Detailed item structure validation (label, sqm, cascoPricePerSqm, parachevementPricePerSqm, amount)
        // happens in the application layer. Firestore Security Rules don't support iterating through lists
        // to validate individual items, so we only validate that items is a list if present.
        let itemsValid = !exists(travauxCommuns.items) || travauxCommuns.items is list;
        
        return enabledValid && itemsValid;
      }

      // Helper function to validate ProjectParams structure
      function isValidProjectParams() {
        let params = request.resource.data.projectParams;

        // If projectParams doesn't exist, validation passes (for partial updates)
        return !(params is map) ||
               (
                 // Validate maxTotalLots: must be int > 0 if present (null is ok)
                 (!('maxTotalLots' in params) ||
                  params.maxTotalLots == null ||
                  (params.maxTotalLots is int && params.maxTotalLots > 0)) &&
                 // Validate travauxCommuns if it exists
                 (!('travauxCommuns' in params) ||
                  isValidTravauxCommuns(params.travauxCommuns))
               );
      }

      // Allow write if lastModifiedBy is set (custom auth system) - must be a non-empty string
      // OR if Firebase Auth user is authenticated
      // Also validate projectParams structure
      allow write: if ((('lastModifiedBy' in request.resource.data) &&
                        request.resource.data.lastModifiedBy is string &&
                        request.resource.data.lastModifiedBy.size() > 0) ||
                       request.auth != null) &&
                     isValidProjectParams();

      // Participants subcollection - individual participant documents
      match /participants/{participantId} {
        // Allow read if unlocked (same as parent project)
        allow read: if true;

        // Helper function to validate Participant structure
        function isValidParticipant() {
          // lotsOwned must be an array if present
          let lotsOwnedValid = !exists(request.resource.data.lotsOwned) || 
                               request.resource.data.lotsOwned is list;
          // enabled must be boolean if present
          let enabledValid = !exists(request.resource.data.enabled) || 
                            request.resource.data.enabled is bool;
          return lotsOwnedValid && enabledValid;
        }

        // Allow write if lastModifiedBy is set (custom auth system) - must be a non-empty string
        // OR if Firebase Auth user is authenticated
        // Also validate participant structure
        allow write: if ((('lastModifiedBy' in request.resource.data) &&
                          request.resource.data.lastModifiedBy is string &&
                          request.resource.data.lastModifiedBy.size() > 0) ||
                         request.auth != null) &&
                       isValidParticipant();
      }
    }

    // Presence collection - for tracking active users
    match /presence/{sessionId} {
      allow read, write: if true; // Presence is ephemeral and not sensitive
    }

    // Edit locks collection - collaborative editing coordination
    match /editLocks/{projectId} {
      // Allow anyone to read locks (to check if a project is locked)
      allow read: if true;

      // Allow anyone to create/update/delete locks
      // Transaction-based atomicity in the code prevents race conditions
      allow create, update, delete: if true;
    }
  }
}
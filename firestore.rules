rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Users collection - store custom authentication data
    match /users/{userId} {
      // Anyone can create a new user (for registration)
      allow create: if true;

      // Users can only read their own data
      allow read: if request.auth != null || request.resource.data.email == userId.replace('_', '@').replace('_', '.');

      // Users cannot update/delete (security measure)
      allow update, delete: if false;
    }

    // Projects collection - shared project data
    match /projects/{projectId} {
      // Allow read if unlocked (we check unlock state in the app)
      allow read: if true;

      // Helper function to validate TravauxCommuns structure
      function isValidTravauxCommuns(travauxCommuns) {
        // enabled must be boolean if present
        let enabledValid = !exists(travauxCommuns.enabled) || travauxCommuns.enabled is bool;
        
        // If items exist, they must be a list
        // Note: Detailed item structure validation (label, sqm, cascoPricePerSqm, parachevementPricePerSqm, amount)
        // happens in the application layer. Firestore Security Rules don't support iterating through lists
        // to validate individual items, so we only validate that items is a list if present.
        let itemsValid = !exists(travauxCommuns.items) || travauxCommuns.items is list;
        
        return enabledValid && itemsValid;
      }

      // Helper function to validate ProjectParams structure
      // IMPORTANT: These rules must handle null/undefined/invalid values gracefully
      // to prevent deployment order issues (rules deployed before UI updates)
      // 
      // DEPLOYMENT ORDER BEST PRACTICE:
      // When adding new validated fields, follow this pattern:
      // 1. Allow null values temporarily (so writes don't fail during transition)
      // 2. UI code should clean up null/invalid values on next save
      // 3. After UI is deployed, rules can be tightened if needed
      //
      // This pattern prevents permission errors when:
      // - Rules are deployed before UI updates
      // - Old UI versions send invalid data
      // - Users have stale data with invalid values
      function isValidProjectParams() {
        // If projectParams doesn't exist, validation passes (for partial updates)
        return !exists(request.resource.data.projectParams) || 
               (
                 // Validate maxTotalLots if it exists
                 // DEFENSIVE: Handle null, undefined, and invalid values gracefully
                 // This prevents permission errors when rules are deployed before UI updates
                 // Strategy: Allow null values (UI will clean them up), but reject 0 and invalid types
                 // Allow if: doesn't exist, is null (will be cleaned by UI), or is valid int > 0
                 (!exists(request.resource.data.projectParams.maxTotalLots) || 
                  request.resource.data.projectParams.maxTotalLots == null || 
                  (request.resource.data.projectParams.maxTotalLots is int && 
                   request.resource.data.projectParams.maxTotalLots > 0)) &&
                 // Validate travauxCommuns if it exists
                 (!exists(request.resource.data.projectParams.travauxCommuns) || 
                  isValidTravauxCommuns(request.resource.data.projectParams.travauxCommuns))
               );
      }

      // Allow write if lastModifiedBy is set (custom auth system) - must be a non-empty string
      // OR if Firebase Auth user is authenticated
      // Also validate projectParams structure if present
      allow write: if ((exists(request.resource.data.lastModifiedBy) && 
                        request.resource.data.lastModifiedBy is string && 
                        request.resource.data.lastModifiedBy.size() > 0) || 
                       request.auth != null) &&
                     isValidProjectParams();

      // Participants subcollection - individual participant documents
      match /participants/{participantId} {
        // Allow read if unlocked (same as parent project)
        allow read: if true;

        // Helper function to validate Participant structure
        function isValidParticipant() {
          // lotsOwned must be an array if present
          let lotsOwnedValid = !exists(request.resource.data.lotsOwned) || 
                               request.resource.data.lotsOwned is list;
          // enabled must be boolean if present
          let enabledValid = !exists(request.resource.data.enabled) || 
                            request.resource.data.enabled is bool;
          return lotsOwnedValid && enabledValid;
        }

        // Allow write if lastModifiedBy is set (custom auth system) - must be a non-empty string
        // OR if Firebase Auth user is authenticated
        // Also validate participant structure
        allow write: if ((exists(request.resource.data.lastModifiedBy) && 
                          request.resource.data.lastModifiedBy is string && 
                          request.resource.data.lastModifiedBy.size() > 0) || 
                         request.auth != null) &&
                       isValidParticipant();
      }
    }

    // Presence collection - for tracking active users
    match /presence/{sessionId} {
      allow read, write: if true; // Presence is ephemeral and not sensitive
    }

    // Edit locks collection - collaborative editing coordination
    match /editLocks/{projectId} {
      // Allow anyone to read locks (to check if a project is locked)
      allow read: if true;

      // Allow anyone to create/update/delete locks
      // Transaction-based atomicity in the code prevents race conditions
      allow create, update, delete: if true;
    }
  }
}